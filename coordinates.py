from subprocess import check_output
from os import system
from tempfile import NamedTemporaryFile


class exonerate(object):
    """
    Object containing the information from the alignment of a sequence to a reference with exonerate. 
    """
    def __init__(self, fasta_seq, fasta_ref):
        """
        Generate the object.
        :param fasta_seq: fasta file of the sequence to align 
        :param fasta_ref: asta file of the reference
        """
        self.fasta_seq, self.fasta_ref = fasta_seq, fasta_ref
        self.ref_name, self.ref_seq = self.get_fasta(self.fasta_ref)
        self.querry_name, self.querry_seq = self.get_fasta(self.fasta_seq)
        # Check the sequence is at least 20 bases long
        assert len(self.querry_seq) >= 20, "ERROR in alignment: The sequence to align should be at least 20 bases long."
        self.str = self.align()
        self.info = self.parse()
        self.coordinates = self.get_coordinates()


    def align(self):
        """
        Use exonerate to make the alignment
        :return: a string containing the result from the alignment
        """
        alignment_str = check_output("exonerate %s %s" % (self.fasta_seq, self.fasta_ref), shell=True)
        return alignment_str


    def parse(self):
        """
        Parse the output string of the alignment of a sequence by exonerate into a dictionary
        :param alignment_str: output string of the alignment of a sequence by exonerate
        :return: a dictionary with the information of the alignment, including 'Target range'
        """
        lines = self.str.strip().split("\n")
        alignment_info = {}
        for line in lines:
            parse_line = line.strip().split(":")
            if len(parse_line) == 2:
                alignment_info[parse_line[0]] = parse_line[1]
        assert "Target range" in alignment_info, "Error: Problem in alignment of %s" % self.querry_seq
        return alignment_info


    def get_coordinates(self):
        """
        Extract the coordinates from the alignment_info dictionary generated by exonerate_parse()
        :param alignment_info: dictionary output from exonerate_parse()
        :return: array containing 2 integers. The coordinates are 0 based, and are a range, so the last coordinates is 
        excluded.
        """
        target_range = self.info["Target range"]
        return [int(x) for x in target_range.split(" -> ")]


    def get_fasta(self, fasta):
        fasta_content = load_fasta(fasta)
        assert len(fasta_content.keys()) == 1, "Error: the fasta file %s contains %d references, " \
                                      "when it should contain only one" % (fasta, len(fasta_content.keys()))
        name = list(fasta_content.keys())[0]
        seq = fasta_content[name]
        assert len(seq) > 0, "Error: there is no sequence corresponding to the name %s" % name
        return name, seq


def load_fasta(fasta):
    """
    From a fasta file, get the sequence and the associated name.
    :param fasta: fasta filename 
    :return: a dictionary containing the sequence and the name of the sequence
    """
    F = open(fasta, "r")
    fasta_content = {}
    line = F.next()
    assert line[0] == ">", "Error: the name of the sequence is not present in %s (line must start by '>', " \
                           "instead the line starts wiht '%s')." % (fasta, line[0:min(5,len(line))])
    name = line.strip(">\n")
    fasta_content[name] = ""
    for line in F:
        if line[0] == ">":
            name = line.strip(">\n")
            assert name not in fasta_content, "Error: the sequence name %s is present more than once in %s" \
                                              % (name, fasta)
            fasta_content[name] = ""
        else:
            fasta_content[name] += line.strip()

    return fasta_content


def formatting(primer_1, primer_2):
    """
    Given the primers sequences, the reference fasta file and the reference name, create 2 fasta files to be used for 
    alignment
    :param primer_1: Sequence of the first primer
    :param primer_2: Sequence of the second primer
    :return: return names of the 2 files that have been created as a list
    """
    fasta_1 = __creating_fasta_from_sequence(primer_1)
    fasta_2 = __creating_fasta_from_sequence(primer_2)
    return fasta_1, fasta_2


def __creating_fasta_from_sequence(seq):
    """
    From a sequence string, create a fasta file
    :param seq: String to be written inside the fasta file 
    :return: Name of the file
    """
    F = NamedTemporaryFile(delete=False)
    filename = F.name
    F.write(">seq\n")
    F.write(seq + "\n")
    F.close()
    return filename


def clean_up_file(filename):
    """
    Erase a file
    :param filename: Name of the file to be erased
    :return: Void
    """
    system("rm %s" % filename)


def get_coordinates(primer_1_seq, primer_2_seq, fasta_ref, buffering=3):
    """
    Given a set of primer, find the sequence and the corresponding coordinates for the bases in a reference sequence
    located between the primers.
    :param primer_1_seq: str, forward primer
    :param primer_2_seq: str, reverse primer
    :param fasta_ref: str, name of the reference file
    :param buffering: integer, number of bases to remove from the reference sequence in addition to the primers
    :return: a set of coordinates (list), the corresponding sequence, and the name of the reference.
    """

    # Get the sequences in the right format: fasta file
    fasta_primer_1, fasta_primer_2 = formatting(primer_1_seq, primer_2_seq)

    # Align the sequences and get the info into an object
    primer_1 = exonerate(fasta_primer_1, fasta_ref)
    primer_2 = exonerate(fasta_primer_2, fasta_ref)

    # Calculate the coordinates between the primers
    if primer_1.coordinates[0] < primer_2.coordinates[0]:
        coord_1 = primer_1.coordinates[1] + buffering
        coord_2 = min(primer_2.coordinates[0], primer_2.coordinates[1]) - buffering  # Notice reverse primer goes from coordinates[1] to coordinates[0]
    else:  # just in case the inputs are reversed
        coord_1 = primer_2.coordinates[1] + buffering
        coord_2 = min(primer_1.coordinates[0], primer_1.coordinates[1]) - buffering

    # Clean-up the temporary fasta file
    clean_up_file(fasta_primer_1)
    clean_up_file(fasta_primer_2)

    # Check the coordinates make sense

    return [coord_1, coord_2], primer_2.ref_seq, primer_2.ref_name
